// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <string.h>

#include "sai_p4_sai.h"
#include <p4_sim/p4_sai_rpc_server.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

extern "C" {
#include <p4_sim/sai.h>
#include <p4_sim/sai_templ.h>
}

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

#define SAI_MAX_ATTR    32
// kludge as learn table not in SAI API
#define SAI_API_LEARN_NOTIFY SAI_API_UNSPECIFIED
using boost::shared_ptr;

using namespace  ::p4_sai_rpc;

// Mac address format converter only for now!
static int convert_string_to_byte(unsigned char *a, std::string s)
{
    int last = -1;
    int rc = sscanf(s.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx%n",
                    a + 0, a + 1, a + 2, a + 3, a + 4, a + 5,
                    &last);
    if(rc != 6 || s.size() != last)
        return -1;
    return 0; 
}

class sai_p4_saiHandler : virtual public sai_p4_saiIf {
 private:
  sai_attribute_t sai_attr[SAI_MAX_ATTR];

 public:
  sai_p4_saiHandler() {
    // Your initialization goes here
  }

  void echo(const std::string& s) {
    // Your implementation goes here
    printf("echo\n");
    std::cerr << "Echo: " << s << std::endl;
  }

  void init() {
    // Your implementation goes here
    printf("init\n");
  }

  void cleanup() {
    // Your implementation goes here
    printf("cleanup\n");
  }

  SessionHandle_t client_init(const int32_t max_txn_size) {
    // Your implementation goes here
    printf("client_init\n");
    return 0;
  }

  int32_t client_cleanup(const SessionHandle_t sess_hdl) {
    // Your implementation goes here
    printf("client_cleanup\n");
    return 0;
  }

//:: def get_type(byte_width):
//::   if byte_width == 1:
//::     return "uint8_t"
//::   elif byte_width == 2:
//::     return "uint16_t"
//::   elif byte_width <= 4:
//::     return "uint32_t"
//::   else:
//::     return "const std::string&"
//::   #endif
//:: #enddef
//::
//:: # match_fields is list of tuples (name, type)
//:: def gen_match_params(match_fields, field_info):
//::   params = []
//::   for field, type in match_fields:
//::     if type == "valid":
//::       params += [(field + "_valid", 1)]
//::       continue
//::     #endif
//::     f_info = field_info[field]
//::     bytes_needed = (f_info["bit_width"] + 7 ) / 8
//::     params += [(field, bytes_needed)]
//::     if type == "lpm": params += [(field + "_prefix_length", 2)]
//::     if type == "ternary": params += [(field + "_mask", bytes_needed)]
//::   #endfor
//::   return params
//:: #enddef
//::
//:: def gen_action_params(names, byte_widths, _get_type = get_type):
//::   params = []
//::   for name, width in zip(names, byte_widths):
//::     name = "action_" + name
//::     params += [(name, width)]
//::   #endfor
//::   return params
//:: #enddef
//::
//::

//:: for table, t_info in table_info.items():

//::   act_prof_name = t_info["action_profile"]
//::   match_type = t_info["match_type"]
//::   has_match_spec = len(t_info["match_fields"]) > 0
//::   if act_prof_name is None:
  int32_t create_${table}(
//::     if has_match_spec:
                const sai_p4_sai_${table}_match_spec_t& match,
//::     #endif
                const sai_attribute_list& attr) {
    sai_${table}_api_t *${table}_api=NULL;
    printf("create_${table} %ld\n", attr.attr_list.size());
    sai_api_query(SAI_API_${table.upper()}, (void **)&${table}_api);
    if(${table}_api) {
        unsigned int i=0;
        for (i=0;i<attr.attr_list.size();i++) {
            sai_attr[i].id = attr.attr_list[i].id;
            sai_attr[i].value.u32 = attr.attr_list[i].value.u32;
        }
        {
//::     if has_match_spec:
            sai_${table}_entry_t entry;
            memset(&entry, 0, sizeof(entry));
//::       match_params = gen_match_params(t_info["match_fields"], field_info)
//::       for name, width in match_params:
//::         if width > 4:
            convert_string_to_byte( entry.${name}, match.${name});
//::         else:
//::           type_ = get_type(width)
            entry.${name} = match.${name};
//::         #endif
//::       #endfor
//::     #endif
            if(attr.attr_list.size() > 0) {
                ${table}_api->create_${table}(
//::     if has_match_spec:
                    &entry,
//::     #endif
                    attr.attr_list.size(), sai_attr);
            }
        }
    }
    return 0;
  }

  int32_t delete_${table}(
//::     if has_match_spec:
                const sai_p4_sai_${table}_match_spec_t& match
//::     #endif
        ) {
    sai_${table}_api_t *${table}_api=NULL;
    printf("delete_${table}\n");
    sai_api_query(SAI_API_${table.upper()}, (void **)&${table}_api);
    if(${table}_api) {
//::     if has_match_spec:
            sai_${table}_entry_t entry;
            memset(&entry, 0, sizeof(entry));
//::       match_params = gen_match_params(t_info["match_fields"], field_info)
//::       for name, width in match_params:
//::         if width > 4:
            convert_string_to_byte( entry.${name}, match.${name});
//::         else:
//::           type_ = get_type(width)
            entry.${name} = match.${name};
//::         #endif
//::       #endfor
//::     #endif
                ${table}_api->remove_${table}(
//::     if has_match_spec:
                    &entry
//::     #endif
                );
    }
//    printf("delete API\n");
    return 0;
  }

//::   else:
//::     # Get the  actions associated with act_prof_name
//::     parent_table = table
//::     parent_actions = t_info["actions"]
//::     table = act_prof_name
//::     act_prof = action_profiles[act_prof_name]
//::     t_info["actions"] = act_prof["actions"]
    // TODO: Add members/Del members
//::   #endif
//:: #endfor

};

/*
 * Thread wrapper for starting the server
 */

static void *sai_rpc_server_thread(void *arg) {
    int port = *(int *) arg;
    shared_ptr<sai_p4_saiHandler> handler(new sai_p4_saiHandler());
    shared_ptr<TProcessor> processor(new sai_p4_saiProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();

    return NULL;
}


static pthread_t sai_rpc_thread;

extern "C" {
extern void sai_init(void);

int start_p4_sai_rpc_server(int port)
{
    std::cerr << "Starting SAI RPC server on port " << port << std::endl;

    int *port_arg = (int *) malloc(sizeof(int));
    *port_arg = port;

    sai_init();

    return pthread_create(&sai_rpc_thread, NULL, sai_rpc_server_thread, port_arg);
}
}
